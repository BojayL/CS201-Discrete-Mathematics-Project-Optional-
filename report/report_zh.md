# 课程项目报告：基于高斯整数环 $\mathbb{Z}[i]$ 的 RSA 算法扩展研究与实现

**学生姓名**：刘博铮 12413116  
**课程名称**：离散数学   
**提交日期**：2025年12月23日

---

## 摘要 
本项目探索了代数数论与密码学的交叉领域，旨在将经典的 RSA 公钥加密系统从传统的整数环 $\mathbb{Z}$ 扩展到高斯整数环 $\mathbb{Z}[i]$。项目的主要目标是研究密码学原语在二次扩张域中的行为特性。通过理论推导与编程实践，我成功设计并实现了一套完全运行在复平面上的 RSA 加密方案。该项目包含一个自定义的高斯整数算术库、一个利用 Cornacchia 算法进行素数分解的密钥生成器，以及一个可视化的图形用户界面 (GUI)。实验分析表明，虽然其数学困难性最终可归约（Reduction）为标准整数分解问题，但高斯 RSA 方案提供了丰富的理论视野，并在素数生成和数据编码方面带来了独特的实现挑战，是深入理解抽象代数在密码学中应用的绝佳案例。

---

## 1. 引言

### 1.1 项目背景
RSA 算法无疑是世界上最著名的公钥加密系统，其安全性建立在大整数分解的困难性之上。在标准的离散数学课程中，我们学习的 RSA 都是在模 $N$ 的整数环 $\mathbb{Z}_N$ 上运算的。然而，抽象代数告诉我们，$\mathbb{Z}$ 仅仅是欧几里得整环 (Euclidean Domain) 的一个特例。

这个项目的诞生源于一个简单的好奇：**“如果我们把 RSA 里的整数换成复数，会发生什么？”**

### 1.2 问题陈述
标准 RSA 算法定义在实整数上。将其移植到复数（具体来说是形式为 $a+bi$ 的高斯整数）上，面临着几个核心挑战：
1.  **次序问题**：复数域没有像整数那样自然的“大小”排序，这使得“带余除法”的概念变得复杂。
2.  **素数概念**：在 $\mathbb{Z}[i]$ 中，“素数”的定义发生了变化。一些我们熟知的整数素数（如 5）在高斯环中不再是素数（因为 $5 = (1+2i)(1-2i)$）。
3.  **算术运算**：我们需要重新定义并实现复数域上的最大公约数 (GCD)、模幂运算等基础算法。

### 1.3 项目目标
本项目的主要目标如下：
1.  深入理解高斯整数环 $\mathbb{Z}[i]$ 的代数结构及其与整数环 $\mathbb{Z}$ 的关系。
2.  设计一套完整的、原生的复数 RSA 密码体制（包括密钥生成、加密、解密）。
3.  使用 Python 实现该系统，并开发 GUI 以增强演示效果。
4.  对比分析该扩展方案与标准 RSA 在效率和安全性上的异同。

---

## 2. 数学理论框架 

要在一个新的数域上实现 RSA，我首先必须建立坚实的数学基础。

### 2.1 高斯整数环 $\mathbb{Z}[i]$
高斯整数集合定义为 $\mathbb{Z}[i] = \{a + bi \mid a, b \in \mathbb{Z}\}$。
它构成了一个**欧几里得整环**，这一点至关重要，因为它意味着**欧几里得算法**（用于求 GCD）在这里依然适用。这是 RSA 密钥生成得以进行的基础。

**范数 (The Norm)**：
为了衡量高斯整数的“大小”，我们引入范数函数：
$$ N(a+bi) = a^2 + b^2 $$
范数有一个核心性质：它是**积性**的，即 $N(\alpha \beta) = N(\alpha)N(\beta)$。这个性质允许我们将复数域上的整除问题映射回我们熟悉的整数算术中。

### 2.2 素数分类定理  - 深入解析
理解“什么让一个高斯整数成为素数”是本项目的核心。在 $\mathbb{Z}$ 中，素数仅仅是“只能被 1 和自身整除的数”。而在 $\mathbb{Z}[i]$ 中，这个概念与“两个整数的平方和”紧密相关。

一个高斯整数 $\pi$ 是素数，当且仅当它满足以下条件之一：

1.  **惰性素数 (Inert Primes, $p \equiv 3 \pmod 4$)**：
    *   **定义**：这些是有理素数，它们在高斯环中依然保持不可分解。
    *   **例子**：$3$ 在 $\mathbb{Z}$ 中是素数。在 $\mathbb{Z}[i]$ 中，不存在整数 $a, b$ 使得 $a^2+b^2=3$。因此，3 无法被分解。
    *   **性质**：它们的范数为 $p^2$。例如 $N(3) = 9$。

2.  **分裂素数 (Split Primes, $p \equiv 1 \pmod 4$)**：
    *   **定义**：这些有理素数在高斯环中是**合数**。它们会分裂成两个共轭的高斯素数：$p = \pi \bar{\pi}$。
    *   **例子**：以 $5$ 为例。因为 $5 \equiv 1 \pmod 4$，根据费马平方和定理，必然存在 $5 = 1^2 + 2^2$。因此，$5 = (1+2i)(1-2i)$。这里，$1+2i$ 就是高斯素数。
    *   **性质**：它们的范数为 $p$。例如 $N(1+2i) = 1^2+2^2 = 5$。

3.  **歧化素数 (Ramified Prime, 2)**：
    *   数字 2 是独特的，因为它分解为 $2 = (1+i)(1-i)$。由于 $1-i = -i(1+i)$，这两个因子是相伴的（Associate）。实际上，2 是一个素数单位的平方。

**可视化理解**：如果我们在复平面上画出所有高斯素数，它们并非随机分布，而是呈现出奇妙的对称性（乘以 $i$ 相当于旋转 90 度）。著名的“高斯护城河 (Gaussian Moat)”问题就是询问是否可以只踩着素数点走向无穷远，这展示了这些数字分布的非平凡性。

### 2.3 广义欧拉函数
标准 RSA 依赖于 $\phi(N) = (p-1)(q-1)$。对于高斯 RSA，我需要推导对应的公式。
若 $M = \pi \rho$ 是两个高斯素数的乘积，则模 $M$ 的乘法群的阶（即欧拉函数）为：
$$ \Phi(M) = (N(\pi) - 1)(N(\rho) - 1) $$
该公式是利用环论中的中国剩余定理推导出来的，它代表了模 $M$ 剩余类环中可逆元的个数。

---

## 3. 算法详细设计 

### 3.1 密钥生成策略
这是设计中最复杂的一环。我们需要生成两个大高斯素数 $\pi$ 和 $\rho$。
我实现了一种混合策略：
*   **方法 A (惰性)**：选取一个大的随机素数 $p$。若 $p \equiv 3 \pmod 4$，则直接令 $\pi = p$。
*   **方法 B (分裂)**：选取一个大的随机素数 $p \equiv 1 \pmod 4$。为了找到对应的 $\pi$，我们需要求解 $p = a^2 + b^2$。我实现了 **Cornacchia-Smith 算法**（欧几里得算法的一个变种）来高效求解 $a$ 和 $b$，从而得到 $\pi = a+bi$。

**算法步骤**：
1.  生成 $\pi$ 和 $\rho$（模数范数约为 512 位）。
2.  计算模数 $M = \pi \rho$。注意这里的 $M$ 是一个复数！
3.  计算欧拉函数 $\Phi(M) = (N(\pi)-1)(N(\rho)-1)$。
4.  选取公钥指数 $e = 65537$。
5.  计算私钥 $d$，满足 $ed \equiv 1 \pmod{\Phi(M)}$。

### 3.2 加密与解密
核心运算与标准 RSA 逻辑一致，但完全在 $\mathbb{Z}[i]$ 上执行：
*   **加密**：$C = P^e \pmod M$
*   **解密**：$P = C^d \pmod M$

### 3.3 数据编码（"嵌入"问题）
高斯 RSA 面临一个独特的工程挑战：**“如何将文本消息表示为一个复数？”**
在标准 RSA 中，我们只是将文本转换为大整数。而在高斯 RSA 中，我们拥有一个二维平面。
**我的解决方案**：我设计了一种编码方案，将二进制消息切分为两部分。一部分作为实部，另一部分作为虚部。这种方法使得我们能在一次加密操作中携带比单纯使用实轴多一倍的信息量，有效利用了该代数结构的二维特性。

---

## 4. 系统实现细节 

项目完全使用 **Python 3** 编写。为了确保我真正掌握了算法细节，我避免使用任何黑盒加密库，而是从零实现了核心数学逻辑。

*   **`gaussian_math.py`**：这是核心引擎。我封装了一个 `GaussianInt` 类，实现了：
    *   重载的 `+`, `-`, `*` 运算符。
    *   `divmod`：自定义的带余除法，通过将复数除法结果四舍五入到最近的高斯整数来确定余数。
    *   `xgcd`：适配复数的扩展欧几里得算法，用于寻找模逆元。
*   **`rsa_core.py`**：处理素数生成、密钥管理和加解密生命周期。
*   **GUI**：使用 Tkinter 构建了图形界面，使项目具备交互性和演示性。

---

## 5. 分析与结果 

### 5.1 复杂度分析
高斯 RSA 效率如何？
理论上，两个复数相乘 $(a+bi)(c+di)$ 需要 4 次整数乘法（使用 Karatsuba 思想可优化至 3 次）以及数次加法。
因此，我们预期在相同模数长度下，高斯 RSA 会比标准 RSA 慢。

### 5.2 基准测试结果
我编写了 benchmark 脚本，将我的实现与同样用 Python 编写的标准整数 RSA 进行对比。
*   **密钥生成**：明显较慢，主要因为需要执行素数分解 ($p=a^2+b^2$)。
*   **加密运算**：大约慢 **5 倍**。这与理论分析相符（复数算术开销 + Python 对象创建开销）。

### 5.3 安全性讨论
使用高斯整数会让 RSA 更安全吗？
其安全性依赖于 **高斯整数分解问题 (GIFP)**。
$$ \text{已知 } M, \text{ 求 } \pi, \rho \text{ 使得 } M = \pi \rho $$
然而，由于 $N(M) = N(\pi)N(\rho)$，在 $\mathbb{Z}[i]$ 中分解 $M$ 在数学上等价于在 $\mathbb{Z}$ 中分解其范数 $N(M)$。
**结论**：其“硬度”与标准 RSA 相同。但是，该系统增加了一层**模糊性 **。攻击者看到的公钥 $M$ 是一个复数，如果他们只有标准整数分解工具，可能会感到困惑。他们必须首先理解代数映射关系，才能将其转化为标准分解问题。

---

## 6. 项目使用手册 

为了保证本项目的可复现性，我在此附上详细的代码运行指南。

### 6.1 环境要求
本项目基于 Python 标准库开发。
*   **Python 版本**：推荐 Python 3.8 或更高版本。
*   **依赖库**：项目主要使用标准库 (`math`, `random`, `tkinter`)，无需额外 `pip install` 即可运行核心功能。

### 6.2 运行步骤
1.  **启动图形界面**：
    在终端中进入项目根目录，运行以下命令：
    ```bash
    python main.py
    ```
    这将打开 "Gaussian RSA Cryptosystem" 窗口。

2.  **功能使用**：
    * **第一步：生成密钥 (KeyGen)**：点击 "Key Generation" 标签页。输入密钥位长（如 128 或 256），点击 "Generate Keys"。系统将显示生成的高斯公钥 $(e, N)$ 和私钥 $(d, N)$。
    
      ![image-20251223233331479](/Users/bojay.l/Library/Application Support/typora-user-images/image-20251223233331479.png)

    * **第二步：加密 (Encryption)**：切换到 "Encryption/Decryption" 标签页。输入文本消息（如 "Hello World"），点击 "Encrypt"。密文将以高斯整数列表的形式显示。
    
    *   **第三步：解密 (Decryption)**：点击 "Decrypt"，系统将利用私钥从密文中恢复出原始消息。
    
3.  **运行性能测试**：
    若要查看高斯 RSA 与标准 RSA 的性能对比数据，请运行：
    
    ```bash
    python analysis/benchmark.py
    ```
    脚本将自动执行不同位长的加密测试，并输出耗时对比。
    
    <img src="/Users/bojay.l/Library/Application Support/typora-user-images/image-20251223233403206.png" alt="image-20251223233403206" style="zoom:50%;" />

---

## 7. 总结与心得 

通过这个项目，我成功证明了 RSA 算法并不局限于整数。通过将算法移植到高斯整数域，我对以下领域有了深刻的理解：
1.  **抽象代数**：深刻体会了“素数”、“GCD”、“同余”等概念在不同环中的推广形式。
2.  **算法数论**：掌握了如 Cornacchia 算法等解决特定数论问题的复杂算法。
3.  **密码系统设计**：理解了在安全性设计中，精确的数学定义是何等重要。

虽然高斯 RSA 在计算上更昂贵，且在理论上没有提供超越标准 RSA 的安全性，但它是一个极佳的桥梁，连接了基础密码学与更高级的、基于类似代数结构的密码系统（如格密码）。

---
*报告结束*
